### 주사위 고르기
[문제링크]([hns/49995](https://school.programmers.co.kr/learn/courses/30/lessons/258709))

# 해결과정
주사위를 고르는 모든 경우, 고른 주사위들을 굴려서 얻을 수 있는 모든 경우, 나머지 주사위들과의 승패 비교

단순 반복문으로 완전탐색을 돌리면 시간초과를 피할 수 없을거 같아서 이진탐색을 적극적으로 활용해줬다

흐름

1. 주사위들을 선택하는 모든 경우의 수 구하기
2. 선택한 주사위들로 조합할 수 있는 모든 정수 저장 (점수판)
3. 나머지 주사위들로 조합할 수 있는 모든 정수 저장 (점수판)
4. 선택한 주사위 조합과 나머지 주사위 조합의 승패를 비교하여 answer 리스트 갱신

1번 과정은 시간을 크게 줄일 수 없다 판단하여 정직하게 완전탐색 dfs를 돌렸다

2번과 3번 과정을 진행할 때 4번 을 빠르게 진행하기 위해 값을 정렬하며 삽입했는데,

이때 이진탐색을 이용해서 값을 정렬했다.

- 코드
    
    target을 list에 삽입할 최소 인덱스를 찾는다. 
    
    ```java
    public int binarySearchMinIndex(ArrayList<Integer> list, int target) {
    		int left = 0;
    		int right = list.size() - 1;
    		while (left <= right) {
    			int mid = (left + right) / 2;
    			if (target <= list.get(mid)) {
    				right = mid - 1;
    			} else {
    				left = mid + 1;
    			}
    		}
    		return left;
    	}
    ```
    
    이진 탐색 쉽지않았다. 아직 조건 거는게 헷갈려서 다른 코드들을 많이 참고 했다.
    

제일 큰 케이스를 다루는 4번 과정을 줄여야 전체적인 시간을 줄일 수 있다고 판단했다. 

점수판을 정렬하며 저장했기 때문에 모든 값을 직접 비교하지 않고 비교할 값이 반대점수판에 몇번째 인덱스에

존재하는지만 확인하면 승리 횟수를 구해줄 수 있다.

`winCnt += 이진탐색으로 구한 인덱스`

승리횟수를 기록하며 최대 승리 횟수를 넘길때마다 정답 주사위 리스트를 갱신한다.
